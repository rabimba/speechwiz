(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.MitchAllen || (g.MitchAllen = {})).MazeGeneratorCore = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/**
    Module: @mitchallen/maze-generator-core/modules/index
    Author: Mitch Allen
*/

/*jshint node: true */
/*jshint esversion: 6 */

"use strict";

/**
 * Connection Grid Core
 * @external @mitchallen/connection-grid-core
 * @see {@link https://www.npmjs.com/package/@mitchallen/connection-grid-core|@mitchallen/connection-grid-core}
 */

/**
 * Maze Generator Core generated by {@link module:maze-generator-core-factory|create}
 * @module maze-generator-core
 * @extends external:@mitchallen/connection-grid-core
 */

/**
 * 
 * A factory for generating maze generator core objects
 * @module maze-generator-core-factory
 */

/** 
* Factory method that returns a maze generator core object.
* It takes one spec parameter that must be an object with named parameters.
* @param {Object} options Named parameters for generating a maze generator core
* @param {grid} options.grid Grid based on {@link external:@mitchallen/connection-grid-core|@mitchallen/connection-grid-core}
* @returns {module:maze-generator-core}
* @example <caption>Creating a maze-generator-core</caption>
* var cgFactory = require("@mitchallen/connection-grid-square"),
*     mazeCore = require("@mitchallen/maze-generator-core"),
*     connectionGrid = cgFactory.create( { x: 5, y: 6 } );
*     maze = mazeCore.create( {
*          grid: connectionGrid,
*     });
*/

module.exports.create = function (spec) {

    spec = spec || {};
    var _grid = spec.grid;

    if (!_grid) {
        return null;
    }

    return Object.assign(_grid, {

        // leave undocumented for now
        carveMaze: function carveMaze(x, y, depth, maxDepth) {

            if (depth >= maxDepth) {
                console.warn("MAXIMUM DEPTH REACHED: %d", maxDepth);
                return;
            }

            if (!this.isCell(x, y)) {
                return;
            }
            var dirs = this.getShuffledNeighborDirs(x, y);
            for (var key in dirs) {
                var sDir = dirs[key];
                var n = this.getNeighbor(x, y, sDir);
                if (n === null) {
                    continue;
                }

                if (this.isMasked(n.x, n.y)) {
                    continue;
                }

                if (this.isCell(n.x, n.y) && !this.hasConnections(n.x, n.y)) {
                    // Connect cell to neighbor
                    this.connectUndirected(x, y, sDir);
                    this.carveMaze(n.x, n.y, depth + 1, maxDepth);
                }
            }
        },

        /**
          * Method called after [generate]{@link module:maze-generator-core#generate} generates a maze.
          * <b>This should be overriden by derived class</b>.
          * The spec parameter will be passed on to this method after the maze has been generated.
          * The derived method should parse spec for needed values.
          * @param {Object} spec Named parameters for method
          * @function
          * @instance
          * @memberof module:maze-generator-core
          * @example <caption>possible usage</caption>
          * // A derived object would have an afterGenerate method that parses spec.open
          * let spec = {
          *    open: [
          *      { border: "N", list: [ 0, 2 ] },
          *      { border: "S", list: [ 3 ] }
          *    ]
          * };
          * mazeGenerator.generate(spec);
          */
        afterGenerate: function afterGenerate(spec) {
            // derived class should override
        },

        /** Generators a maze
          * @param {Object} options Named parameters for generating a maze
          * @param {Array} options.mask An array of cells to mask off from maze generation
          * @param {Array} options.open An array of objects designation what borders to open after generation
          * @param {Object} opions.start An object containing the x and y parameter of a cell to start maze generation from.
          * @function
          * @instance
          * @memberof module:maze-generator-core
          * @returns {boolean}
          * @example <caption>generate</caption>
          * maze.generate();
          * @example <caption>mask</caption>
          * let spec = {
          *    mask: [
          *      { c: 2, r: 3 },
          *      { c: 2, r: 4 }
          *    ]
          * };
          * mazeGenerator.generate(spec);
          * @example <caption>start and mask</caption>
          * let spec = {
          *    start: { c: 3, r: 3 },
          *    mask: [
          *      { c: 0, r: 0 },
          *      { c: 0, r: 1 },
          *      { c: 1, r: 0 },
          *      { c: 1, r: 1 }
          *    ]
          * };
          * mazeGenerator.generate(spec);
          */
        generate: function generate(spec) {

            spec = spec || {};

            var aMask = spec.mask || [],
                start = spec.start || {},
                x = start.c || 0,
                y = start.r || 0;

            this.fill(0);

            for (var mKey in aMask) {
                var mask = aMask[mKey];
                this.mask(mask.c, mask.r);
            }

            var maxDepth = this.xSize * this.ySize;

            this.carveMaze(x, y, 0, maxDepth);

            // derived class can parse extra spec parameters

            this.afterGenerate(spec);
        }
    });
};

},{}]},{},[1])(1)
});